
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://hanyang2508.github.io/cmake%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/">
      
      
        <link rel="prev" href="../Visual%20Studio%20%28VS%29%20%E9%85%8D%E7%BD%AE/">
      
      
        <link rel="next" href="../%E4%BC%AA%E8%B0%B1%E6%B3%95%E5%92%8CFDTD/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.45">
    
    
      
        <title>CMake - Han YANG's BLOG</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.0253249f.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#cmake" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Han YANG&#39;s BLOG" class="md-header__button md-logo" aria-label="Han YANG's BLOG" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Han YANG's BLOG
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              CMake
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Han YANG&#39;s BLOG" class="md-nav__button md-logo" aria-label="Han YANG's BLOG" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Han YANG's BLOG
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Welcome to MkDocs
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C%26CPP%20Debug%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C&CPP Debug笔记
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../CLion%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CLion配置
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Linux%20C%2B%2B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux C++开发环境搭建
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Notes%20On%20CUDA%20C%2B%2B%20Programming%20Guide/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Notes On CUDA C++ Programming Guide
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Visual%20Studio%20%28VS%29%20%E9%85%8D%E7%BD%AE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Visual Studio (VS) 配置
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    CMake
  </span>
  

      </a>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BC%AA%E8%B0%B1%E6%B3%95%E5%92%8CFDTD/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    伪谱法和FDTD
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%85%A8%E6%B3%A2%E5%BD%A2%E5%8F%8D%E6%BC%94%E7%9A%84%E5%8F%82%E6%95%B0%E6%A2%AF%E5%BA%A6%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    全波形反演的参数梯度更新公式推导
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="cmake">CMake</h1>
<p>笔记配套视频教程：<a href="https://www.bilibili.com/video/BV1vR4y1u77h/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0b53107234a299b406bf6f2594c506f1">从零开始详细介绍CMake_哔哩哔哩_bilibili</a>
官网在线文档：<a href="https://cmake.org/documentation/">Documentation | CMake</a>
参考书籍：<a href="https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md">前言 - 《CMake菜谱（CMake Cookbook中文版）》</a></p>
<h1 id="_1">说明</h1>
<p>cmake的定义是什么 ？-----高级编译配置工具</p>
<p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了-----CMake！</p>
<p>所有操作都是通过编译CMakeLists.txt来完成的</p>
<p>官 方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p>
<p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p>
<h1 id="cmake_1">CMake安装</h1>
<p>1、绝大多数的 linux 系统已经安装了 CMake，没有安装的话可以通过 <code>yum install cmake</code> 安装
2、Windows 或某些没有安装过的 linux 系统，去 <a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a> l  可以下载安装</p>
<h1 id="cmakehelloword">CMake一个HelloWord</h1>
<p>1、步骤一，写一个 HelloWord</p>
<pre><code class="language-cpp">#main.cpp
#include &lt;iostream&gt;

int main(){
std::cout &lt;&lt;  &quot;hello word&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>2、步骤二，写 CMakeLists. txt
注意文件名要严格区分大小写</p>
<pre><code class="language-cmake">#CMakeLists.txt

PROJECT (HELLO)

SET(SRC_LIST main.cpp)

MESSAGE(STATUS &quot;This is BINARY dir &quot; ${HELLO_BINARY_DIR})
MESSAGE(STATUS &quot;This is SOURCE dir &quot;${HELLO_SOURCE_DIR})

ADD_EXECUTABLE(hello ${SRC_LIST})
</code></pre>
<p>3、步骤三、使用 cmake，生成 makefile 文件</p>
<pre><code class="language-shell">cmake .

输出：
[root@localhost cmake]# cmake .
CMake Warning (dev) in CMakeLists.txt:
  Syntax Warning in cmake code at

    /root/cmake/CMakeLists.txt:7:37

  Argument not separated from preceding token by whitespace.
This warning is for project developers.  Use -Wno-dev to suppress it.

-- The C compiler identification is GNU 10.2.1
-- The CXX compiler identification is GNU 10.2.1
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- This is BINARY dir /root/cmake
-- This is SOURCE dir /root/cmake
-- Configuring done
-- Generating done
-- Build files have been written to: /root/cmake
</code></pre>
<p>目录下就生成了这些文件-CMakeFiles, CMakeCache. txt, cmake_install. cmake 等文件，并且生成了 Makefile.
现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了 Makefile.</p>
<p>4、使用 make 命令编译</p>
<pre><code class="language-shell">root@localhost cmake]# make
Scanning dependencies of target hello
[100%] Building CXX object CMakeFiles/hello.dir/main.cpp.o
Linking CXX executable hello
[100%] Built target hello
</code></pre>
<p>5、最终生成了 Hello 的可执行程序</p>
<h1 id="cmake-helloword">CMake 一个 HelloWord 的语法介绍</h1>
<h2 id="project">PROJECT 关键字</h2>
<p>可以用来指定工程的名字和支持的语言，默认支持所有语言
<code>PROJECT (HELLO)</code> 指定了工程的名字，并且支持所有语言—建议
<code>PROJECT (HELLO CXX)</code> 指定了工程的名字，并且支持语言是 C++
<code>PROJECT (HELLO C CXX)</code> 指定了工程的名字，并且支持语言是 C 和 C++</p>
<p>该指定隐式定义了两个CMAKE的变量
<code>&lt;projectname&gt;_BINARY_DIR</code>，本例中是 HELLO_BINARY_DIR
<code>&lt;projectname&gt;_SOURCE_DIR</code>，本例中是 HELLO_SOURCE_DIR</p>
<p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p>
<p>问题：如果改了工程名，这两个变量名也会改变
解决：又定义两个预定义变量：<code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCE_DIR</code>，这两个变量和 <code>HELLO_BINARY_DIR</code>，<code>HELLO_SOURCE_DIR</code> 是一致的。所以改了工程名也没有关系</p>
<h2 id="set">SET关键字</h2>
<p>用来显示的指定变量的
<code>SET(SRC_LIST main.cpp)</code>   SRC_LIST 变量就包含了 <code>main.cpp</code>
也可以 <code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p>
<h2 id="message">MESSAGE关键字</h2>
<p>massage 命令向终端输出用户自定义的信息，负责打印 log
主要包含三种信息：
- <code>SEND_ERROR</code>，CMake错误，会继续执行，但是会跳过生成构建系统
- <code>STATUS</code>，比如提示当前使用的编译器
- <code>FATAL_ERROR</code>，CMake致命错误，会终止进程</p>
<h2 id="add_executable">ADD_EXECUTABLE关键字</h2>
<p>生成可执行文件
<code>ADD_EXECUTABLE(hello ${SRC_LIST})</code> 生成的可执行文件名是 hello，源文件读取变量 SRC_LIST 中的内容
也可以直接写 <code>ADD_EXECUTABLE(hello main.cpp)</code></p>
<p>上述例子可以简化的写成</p>
<pre><code class="language-cmake">PROJECT(HELLO)
ADD_EXECUTABLE(hello main.cpp)
</code></pre>
<p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p>
<h1 id="_2">语法的基本原则</h1>
<ul>
<li>变量使用 <code>${}</code> 方式取值，但是在 IF 控制语句中是直接使用变量名</li>
<li>指令 (参数 1 参数 2...) 参数使用括弧括起，参数之间使用空格或分号分开。以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 <code>func.cpp</code> 源文件就要写成：<code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code> 或者 <code>ADD_EXECUTABLE(hello main.cpp; func.cpp)</code></li>
<li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</li>
</ul>
<h2 id="_3">语法注意事项</h2>
<ul>
<li><code>SET(SRC_LIST main.cpp)</code> 可以写成 <code>SET(SRC_LIST “main.cpp”)</code>，如果源文件名中含有空格，就必须要加双引号</li>
<li><code>ADD_EXECUTABLE(hello main)</code> 后缀可以不行，他会自动去找 <code>.c</code> 和 <code>.cpp</code>，最好不要这样写，因为可能会有这两个文件 main. cpp 和 main</li>
</ul>
<h1 id="_4">内部构建和外部构建</h1>
<ul>
<li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li>
<li>外部构建，就会把生成的临时文件放在 build 目录下，不会对源文件有任何影响强烈使用外部构建方式，所以一般采用外部构建的方式</li>
</ul>
<h2 id="_5">外部构建方式举例</h2>
<pre><code class="language-shell">//例子目录，CMakeLists.txt和上面例子一致
[root@localhost cmake]# pwd
/root/cmake
[root@localhost cmake]# ll
total 8
-rw-r--r--. 1 root root 198 Dec 28 20:59 CMakeLists.txt
-rw-r--r--. 1 root root  76 Dec 28 00:18 main.cpp
</code></pre>
<ol>
<li>建立一个 build 目录，可以在任何地方，建议在当前目录下</li>
<li>进入 build，运行 <code>cmake ..</code>    当然 <code>..</code> 表示上一级目录，你可以写 <code>CMakeLists.txt</code> 所在的绝对路径，生产的文件都在 build 目录下了</li>
<li>在 build 目录下，运行 make 来构建工程</li>
</ol>
<p>注意外部构建的两个变量
1. <code>HELLO_SOURCE_DIR</code>  还是工程路径 <code>/root/cmake</code>
2. <code>HELLO_BINARY_DIR</code>   编译路径也就是 <code>/root/cmake/bulid</code></p>
<h1 id="hello-world">让Hello World看起来更像一个工程</h1>
<ul>
<li>为工程添加一个子目录 <code>src</code>，用来放置工程源代码</li>
<li>添加一个子目录 <code>doc</code>，用来放置这个工程的文档 <code>hello.txt</code></li>
<li>在工程目录添加文本文件 <code>COPYRIGHT</code>, <code>README</code></li>
<li>在工程目录添加一个 <code>runhello.sh</code> 脚本，用来调用 hello 二进制</li>
<li>将构建后的目标文件放入构建目录的 bin 子目录</li>
<li>将 doc 目录的内容以及 <code>COPYRIGHT/README</code> 安装到 <code>/usr/share/doc/cmake/</code></li>
</ul>
<h2 id="bin">将目标文件放入构建目录的 bin 子目录</h2>
<p>每个目录下都要有一个<code>CMakeLists.txt</code>说明</p>
<pre><code class="language-css">[root@localhost cmake]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</code></pre>
<p>外层 <code>CMakeLists.txt</code></p>
<pre><code class="language-cmake">PROJECT(HELLO)
ADD_SUBDIRECTORY(src bin)
</code></pre>
<p>src 下的 <code>CMakeLists.txt</code></p>
<pre><code class="language-cmake">ADD_EXECUTABLE(hello main.cpp)
</code></pre>
<h3 id="add_subdirectory">ADD_SUBDIRECTORY 指令</h3>
<p><code>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code>
- 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置
- <code>EXCLUDE_FROM_ALL</code> 函数是将写的目录从编译中排除，如程序中的 example
- <code>ADD_SUBDIRECTORY(src bin)</code>
    - 将 <code>src</code> 子目录加入工程并指定编译输出 (包含编译中间结果) 路径为 <code>bin</code> 目录
    - 如果不进行 <code>bin</code> 目录的指定，那么编译结果 (包括中间结果) 都将存放在 <code>build/src</code> 目录</p>
<h3 id="_6">更改二进制的保存路径</h3>
<p><code>SET</code> 指令重新定义 <code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code> 变量 来指定最终的目标二进制的位置
<code>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</code>
<code>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</code></p>
<p>思考：<code>ADD_SUBDIRECTORY</code> 指令加在哪个 <code>CMakeLists.txt</code> 当中
哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在 <code>src</code> 下的 <code>CMakeLists.txt</code> 下写</p>
<h1 id="_7">安装</h1>
<ul>
<li>一种是从代码编译后直接 <code>make install</code> 安装</li>
<li>一种是打包时的指定 目录安装。<ul>
<li>简单的可以这样指定目录：<code>make install DESTDIR=/tmp/test</code></li>
<li>稍微复杂一点可以这样指定目录：<code>./configure –prefix=/usr</code></li>
</ul>
</li>
</ul>
<h2 id="helloword">如何安装HelloWord</h2>
<p>使用CMAKE一个新的指令：<code>INSTALL</code>
INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等
使用CMAKE一个新的变量：<code>CMAKE_INSTALL_PREFIX</code></p>
<pre><code class="language-css">// 目录树结构
[root@localhost cmake]# tree
.
├── build
├── CMakeLists.txt
├── COPYRIGHT
├── doc
│   └── hello.txt
├── README
├── runhello.sh
└── src
    ├── CMakeLists.txt
    └── main.cpp

3 directories, 7 files
</code></pre>
<h3 id="copyright-readme">安装文件 COPYRIGHT 和 README</h3>
<p>FILES：文件
<code>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</code>
- DESTINATION：
    - 可以写绝对路径
    - 可以写相对路径，相对路径实际路径是：<code>${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</code>
        - 其中 <code>CMAKE_INSTALL_PREFIX</code>  默认是在 <code>/usr/local/</code></p>
<p><code>cmake -D CMAKE_INSTALL_PREFIX=/usr</code> 在 cmake 的时候指定 <code>CMAKE_INSTALL_PREFIX</code> 变量的路径</p>
<h3 id="runhello-sh">安装脚本 runhello. sh</h3>
<p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)
<code>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</code></p>
<p>说明：实际安装到的是 /usr/bin</p>
<h3 id="doc-hellotxt">安装 doc 中的 hello.txt</h3>
<ul>
<li>通过在 doc 目录建立<code>CMakeLists.txt</code>，通过install下的file</li>
<li>直接在工程目录通过 <code>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</code> 安装<ul>
<li>DIRECTORY 后面连接的是所在 Source 目录的相对路径</li>
</ul>
</li>
</ul>
<p>注意：<code>abc</code> 和 <code>abc/</code>有很大的区别
- 目录名不以/结尾：这个<strong>目录</strong>将被安装为目标路径下的
- 目录名以/结尾：将这个<strong>目录中的内容</strong>安装到目标路径</p>
<h3 id="_8">安装过程</h3>
<pre><code class="language-shell">cmake ..
make
make install
</code></pre>
<h1 id="_9">静态库和动态库的构建</h1>
<p>任务：
1. 建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。
2. 安装头文件与共享库。</p>
<p>静态库和动态库的区别
- 静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。
- 静态库在编译时会直接整合到目标程序中，编译成功的可执行文件离开静态库后仍然可独立运行
- 动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p>
<h2 id="_10">构建实例</h2>
<pre><code class="language-css">[root@localhost cmake2]# tree
.
├── build
├── CMakeLists.txt
└── lib
    ├── CMakeLists.txt
    ├── hello.cpp
    └── hello.h
</code></pre>
<p>hello.h中的内容</p>
<pre><code class="language-cpp">#ifndef HELLO_H
#define Hello_H

void HelloFunc();

#endif
</code></pre>
<p>hello.cpp中的内容</p>
<pre><code class="language-cpp">#include &quot;hello.h&quot;
#include &lt;iostream&gt;
void HelloFunc(){
    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;
}
</code></pre>
<p>项目中的cmake内容</p>
<pre><code class="language-cmake">PROJECT(HELLO)
ADD_SUBDIRECTORY(lib bin)
</code></pre>
<p>lib 中 CMakeLists. txt 中的内容
- 第一行定义了一个变量，叫 LIBHELLO_SRC，该变量里面放了 hello.cpp</p>
<pre><code class="language-cmake">SET(LIBHELLO_SRC hello.cpp)
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
</code></pre>
<h3 id="add_library">ADD_LIBRARY</h3>
<p><code>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</code>
- hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so
- SHARED，动态库；STATIC，静态库
- ${LIBHELLO_SRC} ：源文件</p>
<p>补充：静态库的文件拓展名通常为. lib（Windows）或者. a（Linux）；动态库的文件拓展名通常为. dll (Windows) 或者. so（Linux）</p>
<h3 id="_11">同时构建静态和动态库</h3>
<pre><code class="language-cmake">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})

// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})
ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
</code></pre>
<h3 id="set_target_properties">SET_TARGET_PROPERTIES</h3>
<p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>
<p>同时构建静态和动态库</p>
<pre><code class="language-cmake">SET(LIBHELLO_SRC hello.cpp)

ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})

//对hello_static的重名为hello
SET_TARGET_PROPERTIES(hello_static PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a
SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)


ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})

SET_TARGET_PROPERTIES(hello PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)

</code></pre>
<h3 id="_12">动态库的版本号</h3>
<p>一般动态库都有一个版本号的关联</p>
<pre><code class="language-cpp">libhello.so.1.2
libhello.so -&gt;libhello.so.1
libhello.so.1-&gt;libhello.so.1.2
</code></pre>
<p>CMakeLists.txt 插入如下</p>
<pre><code class="language-cmake">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)
</code></pre>
<p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p>
<h3 id="_13">安装共享库和头文件</h3>
<p>本例中我们将 hello 的共享库安装到<code>&lt;prefix&gt;/lib</code>目录，
将 hello.h 安装到<code>&lt;prefix&gt;/include/hello</code> 目录
其中 <code>ARCHIVE</code> 特指静态库，<code>LIBRARY</code> 特指动态库，<code>RUNTIME</code> 特指可执行目标二进制。</p>
<pre><code class="language-cmake">//文件放到该目录下
INSTALL(FILES hello.h DESTINATION include/hello)

//二进制，静态库，动态库安装都用TARGETS
INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
</code></pre>
<p>注意：
安装的时候，指定一下路径，放到系统下
<code>cmake -D CMAKE_INSTALL_PREFIX=/usr ..</code></p>
<h3 id="_14">使用外部共享库和头文件</h3>
<p>准备工作，新建一个目录来使用外部共享库和头文件</p>
<pre><code class="language-css">[root@MiWiFi-R4CM-srv cmake3]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp
</code></pre>
<p>main.cpp</p>
<pre><code class="language-cpp">#include &lt;hello.h&gt;

int main(){
    HelloFunc();
}
</code></pre>
<h3 id="make">解决：make 后头文件找不到的问题</h3>
<p>PS：<code>include &lt;hello/hello.h&gt;</code>  这样include是可以，这么做的话，就没啥好讲的了</p>
<p>关键字：<code>INCLUDE_DIRECTORIES</code> 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割
在<code>CMakeLists.txt</code>中加入头文件搜索路径
<code>INCLUDE_DIRECTORIES(/usr/include/hello)</code></p>
<h3 id="_15">解决：找到引用的函数问题</h3>
<p>报错信息：<code>undefined reference to HelloFunc()</code></p>
<ul>
<li>关键字：<code>LINK_DIRECTORIES</code> 添加非标准的共享库搜索路径指定第三方库所在路径，<code>LINK_DIRECTORIES(/home/myproject/libs)</code></li>
<li>关键字：<code>TARGET_LINK_LIBRARIES</code> 添加需要链接的共享库
<code>TARGET_LINK_LIBRARIES</code> 的时候，只需要给出动态链接库的名字就行了。</li>
</ul>
<p>在 <code>CMakeLists. txt</code> 中插入链接共享库，必须要插在 <code>ADD_EXECUTABLE</code> 的后面， <code>TARGET_LINK_LIBRARIES(main libhello.so)</code>  </p>
<p>查看main的链接情况</p>
<pre><code class="language-sh">[root@MiWiFi-R4CM-srv bin]# ldd main 
    linux-vdso.so.1 =&gt;  (0x00007ffedfda4000)
    libhello.so =&gt; /lib64/libhello.so (0x00007f41c0d8f000)
    libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f41c0874000)
    libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f41c0572000)
    libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f41c035c000)
    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f41bff8e000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f41c0b7c000)
</code></pre>
<p>链接静态库 </p>
<pre><code class="language-cmake">TARGET_LINK_LIBRARIES(main libhello.a)
</code></pre>
<h3 id="cmake_include_path-cmake_library_path">特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3>
<p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p>
<p>我们上面例子中使用了绝对路径 <code>INCLUDE_DIRECTORIES(/usr/include/hello)</code> 来指明 include 路径的位置 </p>
<p>我们还可以使用另外一种方式，使用环境变量 <code>export CMAKE_INCLUDE_PATH=/usr/include/hello</code> </p>
<p>补充：生成 debug 版本的方法，后续可以使用 GDB 调试</p>
<pre><code class="language-sh">cmake .. -D CMAKE_BUILD_TYPE=debug
</code></pre>
<h1 id="_16">其他补充教程以及参考资料</h1>
<h2 id="cmake_2">CMake 流程</h2>
<p>注意：CMake 是没有带编译工具的，需要自己安装 C++的编译工具。如 Windows 下的 MSBuild 工具链或者直接安装 Visual Studio，在 Linux 下则需要安装 gcc 或者 clang 等等。</p>
<h3 id="configure">配置（Configure）</h3>
<p>命令 <code>cmake -S . -B build</code></p>
<p>在项目的根目录下创建 CMakeLists. txt 文件</p>
<p>对于一个最简单的只包含一个源文件的工程，以下三行并不可少</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.25)  

project(Example)  

add_executable(Example main.cpp) 
</code></pre>
<p>随后可以根据这个 CMakeLists 文件生成目标平台下的原生工程，这个过程在 CMake 中叫做“配置（Configure）”</p>
<h3 id="build">构建（Build）</h3>
<p>命令 <code>cmake --build build</code> 构建完成后会输出可执行文件</p>
<p>复杂项目的 CMakeLists. txt 样例</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.5)

project(Blackhole)

list(APPEND CMAKE_MODULE_PATH ${CMAKE_BINARY_DIR})
list(APPEND CMAKE_PREFIX_PATH ${CMAKE_BINARY_DIR})

if(NOT EXISTS &quot;${CMAKE_BINARY_DIR}/conan.cmake&quot;)
  message(STATUS &quot;Downloading conan.cmake from https://github.com/conan-io/cmake-conan&quot;)
  file(DOWNLOAD &quot;https://raw.githubusercontent.com/conan-io/cmake-conan/v0.16.1/conan.cmake&quot;
                &quot;${CMAKE_BINARY_DIR}/conan.cmake&quot;
                EXPECTED_HASH SHA256=396e16d0f5eabdc6a14afddbcfff62a54a7ee75c6da23f32f7a31bc85db23484
                TLS_VERIFY ON)
endif()

include(${CMAKE_BINARY_DIR}/conan.cmake)

conan_cmake_configure(REQUIRES imgui/1.86 glfw/3.3.6 glew/2.2.0 glm/0.9.9.8 stb/cci.20210713
                      GENERATORS cmake_find_package)

conan_cmake_autodetect(settings)

conan_cmake_install(PATH_OR_REFERENCE .
                    BUILD missing
                    REMOTE conancenter
                    SETTINGS ${settings})

find_package(imgui REQUIRED)
find_package(glfw3 REQUIRED)
find_package(GLEW REQUIRED)
find_package(glm REQUIRED)
find_package(stb REQUIRED)

file(GLOB SRC_FILES
  &quot;${PROJECT_SOURCE_DIR}/src/*.h&quot;
  &quot;${PROJECT_SOURCE_DIR}/src/*.cpp&quot;
  &quot;${PROJECT_SOURCE_DIR}/src/*.c&quot;
  &quot;${PROJECT_SOURCE_DIR}/src/*.cc&quot;)

add_executable(${CMAKE_PROJECT_NAME} ${SRC_FILES})

target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE imgui::imgui)
target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE glfw)
target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE GLEW::GLEW)
target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE glm::glm)
target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE stb::stb)

target_compile_features(${CMAKE_PROJECT_NAME} PRIVATE cxx_std_17)

# Copy assets files after build.
add_custom_command(
  TARGET ${CMAKE_PROJECT_NAME}
  POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_directory &quot;${PROJECT_SOURCE_DIR}/assets&quot;
          &quot;$&lt;TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}&gt;/assets&quot;)

add_custom_command(
  TARGET ${CMAKE_PROJECT_NAME}
  POST_BUILD
  COMMAND ${CMAKE_COMMAND} -E copy_directory &quot;${PROJECT_SOURCE_DIR}/shader/&quot;
          &quot;$&lt;TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}&gt;/shader&quot;)
</code></pre>
<p>微软开源包工具：vcpkg</p>
<p>参考资料：
-  <a href="https://zhuanlan.zhihu.com/p/371257515">CMake应用：CMakeLists.txt完全指南 - 知乎</a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>